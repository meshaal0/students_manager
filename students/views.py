from django.shortcuts import render,redirect
from django.http import FileResponse
from .utils.pdf_generator import generate_barcodes_pdf
from django.shortcuts import get_object_or_404
from django.http import HttpResponse
from .models import Students,Attendance,Payment,Basics
from .utils.barcode_utils import generate_barcode_image
from .utils.whatsapp_queue import queue_whatsapp_message
import os
from django.conf import settings
from django.contrib import messages
from django.utils import timezone
import threading
from datetime import date
from datetime import timedelta
import logging

logger = logging.getLogger(__name__)

# INITIAL_FREE_TRIES = 3 # Removed as free_tries will be fetched from Basics model

# def print_student_card(request, student_id):
#     student = get_object_or_404(Students, id=student_id)
#     pdf_io = generate_student_card_pdf(student)
#     return FileResponse(
#         pdf_io, as_attachment=True,
#         filename=f"{student.barcode}_card.pdf",
#         content_type="application/pdf"
#     )

def print_barcode(request, student_id):
    student = get_object_or_404(Students, id=student_id)
    full_path = os.path.join(settings.MEDIA_ROOT, 'barcodes', f"{student.barcode}.png")

    # Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† Ø§Ù„Ø¨Ø§Ø±ÙƒÙˆØ¯ Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹ØŒ Ù†Ù‚ÙˆÙ… Ø¨ØªÙˆÙ„ÙŠØ¯Ù‡
    if not os.path.exists(full_path):
        generate_barcode_image(student.barcode)

    if os.path.exists(full_path):
        return FileResponse(open(full_path, "rb"), content_type="image/png")
    else:
        return HttpResponse("ÙØ´Ù„ ÙÙŠ ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø¨Ø§Ø±ÙƒÙˆØ¯", status=404)
    
def download_barcodes_pdf(request):
    pdf = generate_barcodes_pdf()
    return FileResponse(pdf, as_attachment=True, filename='barcodes.pdf')

# Helper function for 'scan' action
def _handle_scan_action(request, student, today, paid_for_month, barcode_value, context, basics_settings):
    if paid_for_month:
        Attendance.objects.create(student=student, attendance_date=today)
        messages.success(request, f"âœ… ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø­Ø¶ÙˆØ± {student.name} Ø¨Ù†Ø¬Ø§Ø­.")
        _send_whatsapp_attendance(student, today)
        return redirect('barcode_attendance')
    else:
        # Not paid: show options for payment or free tries
        context.update({
            'pending_student': student,
            'barcode': barcode_value, # Use the passed barcode_value
        })
        if student.free_tries > 0:
            messages.warning(
                request,
                f"â— Ù„Ø¯ÙŠÙƒ {student.free_tries} {'ÙØ±ØµØ©' if student.free_tries==1 else 'ÙØ±Øµ'} Ù…Ø¬Ø§Ù†ÙŠØ© Ù‚Ø¨Ù„ Ø§Ù„Ø¯ÙØ¹."
            )
        else:
            messages.warning(
                request,
                "âš ï¸ Ø§Ù†ØªÙ‡Øª ÙØ±ØµÙƒ Ø§Ù„Ù…Ø¬Ø§Ù†ÙŠØ© Ù„Ù‡Ø°Ø§ Ø§Ù„Ø´Ù‡Ø±ØŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø¯ÙØ¹."
            )
        # This path needs to render the template, not redirect, to show the context
        return render(request, 'attendance.html', context) 

# Helper function for 'free' action
def _handle_free_action(request, student, today, basics_settings):
    if student.free_tries > 0:
        student.free_tries -= 1
        student.save()
        Attendance.objects.create(student=student, attendance_date=today)
        messages.success(
            request,
            f"âœ… Ø­Ø¶ÙˆØ± Ù…Ø¬Ø§Ù†ÙŠÙ‘. ØªØ¨Ù‚Ù‰ Ù„Ø¯ÙŠÙƒ {student.free_tries} {'ÙØ±ØµØ©' if student.free_tries==1 else 'ÙØ±Øµ'}."
        )
        text = (
            f"ğŸ‘‹ *Ù…Ø±Ø­Ø¨Ø§Ù‹ ÙˆÙ„ÙŠ Ø£Ù…Ø± Ø§Ù„Ø·Ø§Ù„Ø¨ {student.name}ØŒ*\n\n"
            f"âœ… Ø³Ø¬Ù„Ù†Ø§ Ø­Ø¶ÙˆØ± Ø§Ù„ÙŠÙˆÙ… ÙƒÙØ±ØµØ© Ù…Ø¬Ø§Ù†ÙŠØ©.\n"
            f"ğŸ“Œ ØªØ¨Ù‚Ù‰ {student.free_tries} {'ÙØ±ØµØ©' if student.free_tries==1 else 'ÙØ±Øµ'} Ù„Ù‡Ø°Ø§ Ø§Ù„Ø´Ù‡Ø±.\n\n"
            f"ğŸ¯ Ù†Ù†ØµØ­ Ø¨Ø³Ø¯Ø§Ø¯ Ø§Ù„Ø§Ø´ØªØ±Ø§Ùƒ Ù„Ø¶Ù…Ø§Ù† Ø§Ø³ØªÙ…Ø±Ø§Ø± Ø§Ù„Ø­Ø¶ÙˆØ± Ø¯ÙˆÙ† Ø­Ø¯ÙˆØ¯.\n\n"
            f"â€“ Ù…. Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡ Ø¹Ù…Ø±"
        )
        logger.info(f"Attempting to queue WhatsApp message to {student.father_phone} for student {student.name} (type: free_action)")
        try:
            thread = threading.Thread(
                target=queue_whatsapp_message,
                args=(student.father_phone, text),
                daemon=True
            )
            thread.start()
        except Exception as e:
            logger.error(f"Failed to start WhatsApp thread for student {student.name} (phone: {student.father_phone}, type: free_action): {e}")
    else:
        messages.error(request, "âŒ Ù„Ø§ ØªÙˆØ¬Ø¯ ÙØ±Øµ Ù…Ø¬Ø§Ù†ÙŠØ© Ù…ØªØ¨Ù‚ÙŠØ©ØŒ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ø¯ÙØ¹.")
    return redirect('barcode_attendance')

# Helper function for 'pay' action
def _handle_pay_action(request, student, today, month_start, basics_settings):
    payment, created = Payment.objects.get_or_create(
        student=student,
        month=month_start
    )
    # Reset free tries using basics_settings
    student.free_tries = basics_settings.free_tries 
    student.last_reset_month = today.replace(day=1)
    student.save()

    Attendance.objects.create(student=student, attendance_date=today)
    
    # Use month_price from basics_settings
    month_price_value = basics_settings.month_price 
    dp_msg = (
        f"âœ… ØªÙ… Ø§Ø³ØªÙ„Ø§Ù… Ø§Ø´ØªØ±Ø§Ùƒ Ø´Ù‡Ø± {payment.month:%B %Y}. Ø¨Ù…Ø¨Ù„Øº {month_price_value} ÙÙ‚Ø· Ù„Ø§ ØºÙŠØ±"
        if created else
        f"â„¹ï¸ Ø¯ÙØ¹ØªÙƒ Ù„Ø´Ù‡Ø± {payment.month:%B %Y} Ù…Ø³Ø¬Ù„Ù‘Ø© Ù…Ø³Ø¨Ù‚Ø§Ù‹."
    )
    at_msg = f"âœ… ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø­Ø¶ÙˆØ± {student.name} Ø§Ù„ÙŠÙˆÙ… {today:%Y-%m-%d}."

    # _send_whatsapp_combined handles its own logging for queueing
    _send_whatsapp_combined(student, dp_msg, at_msg)
    messages.success(request, dp_msg)
    messages.success(request, at_msg)
    return redirect('barcode_attendance')


def barcode_attendance_view(request):
    context = {}
    today = timezone.localdate()
    context['now'] = today # For displaying current month in template if needed

    basics_settings = Basics.objects.first()
    if basics_settings is None:
        messages.error(request, "Error: Basic settings not configured. Please contact admin.")
        return redirect('barcode_attendance')

    if request.method == 'POST':
        action  = request.POST.get('action', 'scan')
        barcode = request.POST.get('barcode', '').strip()

        try:
            student = Students.objects.get(barcode=barcode)
        except Students.DoesNotExist:
            messages.error(request, "âŒ Ù‡Ø°Ø§ Ø§Ù„Ø¨Ø§Ø±ÙƒÙˆØ¯ ØºÙŠØ± ØµØ§Ù„Ø­. Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.")
            return redirect('barcode_attendance')

        if Attendance.objects.filter(student=student, attendance_date=today).exists():
            messages.warning(request, f"âš ï¸ Ø­Ø¶ÙˆØ± {student.name} Ø§Ù„ÙŠÙˆÙ… Ù…Ø³Ø¬Ù‘Ù„ Ù…Ø³Ø¨Ù‚Ø§Ù‹.")
            return redirect('barcode_attendance')

        month_start = date(today.year, today.month, 1)
        paid_for_month = Payment.objects.filter(student=student, month=month_start).exists()

        if action == 'scan':
            return _handle_scan_action(request, student, today, paid_for_month, barcode, context, basics_settings)
        elif action == 'free':
            return _handle_free_action(request, student, today, basics_settings)
        elif action == 'pay':
            return _handle_pay_action(request, student, today, month_start, basics_settings)
        else:
            # Should not happen if action is always one of the above
            messages.error(request, "Action ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ.")
            return redirect('barcode_attendance')

    return render(request, 'attendance.html', context)


def _send_whatsapp_attendance(student, today):
    date_str = today.strftime('%Y-%m-%d')
    time_str = timezone.localtime().strftime('%H:%M')
    text = (
        f"ğŸ‘‹ *Ù…Ø±Ø­Ø¨Ø§Ù‹ ÙˆÙ„ÙŠ Ø£Ù…Ø± Ø§Ù„Ø·Ø§Ù„Ø¨ {student.name}ØŒ*\n\n"
        f"ğŸ“Œ *ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø­Ø¶ÙˆØ± Ø¨Ù†Ø¬Ø§Ø­.*\n"
        f"ğŸ—“ï¸ Ø§Ù„ØªØ§Ø±ÙŠØ®: `{date_str}`\n"
        f"â° Ø§Ù„ÙˆÙ‚Øª: `{time_str}`\n\n"
        f"ğŸ“š Ù†ØªÙ…Ù†Ù‰ Ù„Ù‡ ÙŠÙˆÙ…Ø§Ù‹ Ù…ÙˆÙÙ‚Ø§Ù‹!\n\n"
        f"Ù…Ø¹ ØªØ­ÙŠØ§ØªØŒ\n*Ù…. Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡ Ø¹Ù…Ø±* ğŸ˜"
    )
    logger.info(f"Attempting to queue WhatsApp message to {student.father_phone} for student {student.name} (type: attendance_confirmation)")
    try:
        thread = threading.Thread(
            target=queue_whatsapp_message,
            args=(student.father_phone, text),
            daemon=True
        )
        thread.start()
    except Exception as e:
        logger.error(f"Failed to start WhatsApp thread for student {student.name} (phone: {student.father_phone}, type: attendance_confirmation): {e}")

def _send_whatsapp_combined(student, dp_msg, at_msg):
    text = (
        f"ğŸ‘‹ *Ù…Ø±Ø­Ø¨Ø§Ù‹ ÙˆÙ„ÙŠ Ø£Ù…Ø± Ø§Ù„Ø·Ø§Ù„Ø¨ {student.name}ØŒ*\n\n"
        f"{dp_msg}\n"
        f"{at_msg}\n\n"
        f"ğŸ“š Ø´ÙƒØ±Ø§Ù‹ Ù„ØªØ¹Ø§ÙˆÙ†ÙƒÙ…!\n\n"
        f"Ù…Ø¹ ØªØ­ÙŠØ§ØªØŒ\n*Ù…. Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡ Ø¹Ù…Ø±* ğŸ˜"
    )
    logger.info(f"Attempting to queue WhatsApp message to {student.father_phone} for student {student.name} (type: payment_confirmation_and_attendance)")
    try:
        thread = threading.Thread(
            target=queue_whatsapp_message,
            args=(student.father_phone, text),
            daemon=True
        )
        thread.start()
    except Exception as e:
        logger.error(f"Failed to start WhatsApp thread for student {student.name} (phone: {student.father_phone}, type: payment_confirmation_and_attendance): {e}")


def get_absence_message(student, today, consecutive_days, total_absences):
    """
    ÙŠÙØ¹ÙŠØ¯ Ø±Ø³Ø§Ù„Ø© Ù…ÙØ®ØµØµØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰:
    - consecutive_days: Ø¹Ø¯Ø¯ Ø§Ù„Ø£ÙŠØ§Ù… Ø§Ù„Ù…ØªØªØ§Ø¨Ø¹Ø© Ù„Ù„ØºÙŠØ§Ø¨ Ø­ØªÙ‰ Ø§Ù„ÙŠÙˆÙ…
    - total_absences: Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø¹Ø¯Ø¯ Ø£ÙŠØ§Ù… Ø§Ù„ØºÙŠØ§Ø¨ ÙÙŠ Ø§Ù„Ø´Ù‡Ø± Ø§Ù„Ø­Ø§Ù„ÙŠ
    """
    date_str = today.strftime("%Y-%m-%d")
    base_header = f"ğŸ“¢ *ØªÙ†Ø¨ÙŠÙ‡ ÙˆÙ„ÙŠ Ø£Ù…Ø± Ø§Ù„Ø·Ø§Ù„Ø¨ {student.name}*\n\n"
    signature = "\n\nÙ…Ø¹ ØªØ­ÙŠØ§ØªØŒ\n*Ù…. Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡ Ø¹Ù…Ø±*"

    # Ø£ÙˆÙ„ ØºÙŠØ§Ø¨ Ù„Ù„Ø·Ø§Ù„Ø¨ ÙÙŠ Ø§Ù„Ø´Ù‡Ø±
    if total_absences == 1 and consecutive_days == 1:
        return (
            base_header +
            f"âŒ ØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø£ÙˆÙ„ ØºÙŠØ§Ø¨ Ù„Ø§Ø¨Ù†Ùƒ/Ø§Ø¨Ù†ØªÙƒ Ø§Ù„ÙŠÙˆÙ… ({date_str}).\n"
            "ğŸ“Œ Ù†Ø±Ø¬Ùˆ Ø§Ø·Ù„Ø§Ø¹Ù†Ø§ Ø¹Ù„Ù‰ Ø³Ø¨Ø¨ Ø§Ù„ØºÙŠØ§Ø¨ ÙˆØªØ²ÙˆÙŠØ¯Ù†Ø§ Ø¨Ø¥ÙØ§Ø¯Ø© Ø¥Ø°Ø§ Ù„Ø²Ù… Ø§Ù„Ø£Ù…Ø±." +
            signature
        )

    # ØºÙŠØ§Ø¨ Ù…ØªØªØ§Ø¨Ø¹ ÙŠÙˆÙ…ÙŠÙ†
    if consecutive_days == 2:
        return (
            base_header +
            f"âš ï¸ ØªÙ… ØªØ³Ø¬ÙŠÙ„ ØºÙŠØ§Ø¨ Ø§Ø¨Ù†Ùƒ/Ø§Ø¨Ù†ØªÙƒ Ù„Ù„ÙŠÙˆÙ… Ø§Ù„Ø«Ø§Ù†ÙŠ Ø¹Ù„Ù‰ Ø§Ù„ØªÙˆØ§Ù„ÙŠ ({date_str}).\n"
            "ğŸ“Œ Ù†Ø±Ø¬Ùˆ ØªØ²ÙˆÙŠØ¯Ù†Ø§ Ø¨Ù…Ø¨Ø±Ø± Ø§Ù„ØºÙŠØ§Ø¨ Ù„Ù…Ø³Ø§Ø¹Ø¯ØªÙ†Ø§ ÙÙŠ Ù…ØªØ§Ø¨Ø¹Ø© Ø­Ø§Ù„ØªÙ‡ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠØ©." +
            signature
        )

    # ØºÙŠØ§Ø¨ Ù…ØªØªØ§Ø¨Ø¹ 3 Ø£ÙŠØ§Ù… Ø£Ùˆ Ø£ÙƒØ«Ø±
    if consecutive_days >= 3:
        return (
            base_header +
            f"ğŸš¨ ØºÙŠØ§Ø¨ Ù…ØªØªØ§Ø¨Ø¹: Ø§Ø¨Ù†Ùƒ/Ø§Ø¨Ù†ØªÙƒ ØºØ§Ø¦Ø¨ Ù…Ù†Ø° {consecutive_days} Ø£ÙŠØ§Ù… Ø­ØªÙ‰ ({date_str}).\n"
            "ğŸ“Œ Ù†Ø·Ù„Ø¨ Ù…Ù†ÙƒÙ… Ø§Ù„ØªÙˆØ§ØµÙ„ Ø¹Ø§Ø¬Ù„Ø§Ù‹ Ù„ØªÙˆØ¶ÙŠØ­ Ø§Ù„ÙˆØ¶Ø¹ ÙˆØªÙØ§Ø¯ÙŠ Ø§Ù„ØªØ£Ø«ÙŠØ± Ø§Ù„Ø³Ù„Ø¨ÙŠ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø¯Ø±Ø§Ø³ÙŠ.\n" +
            "Ø§Ù† ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø§ÙŠ Ù…Ø´Ø§ÙƒÙ„ Ø§Ùˆ Ø´ÙƒÙˆÙ‰ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ø¨Ù„Ø§ØºÙ†Ø§ ÙˆÙ†Ø¹Ø¯ Ø¨Ø§Ù†Ù†Ø§ Ø³Ù†Ø¹Ù…Ù„ Ø¹Ù„Ù‰ Ø­Ù„Ù‡Ø§ ÙˆØ§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø§Ù† Ø´Ø§Ø¡ Ø§Ù„Ù„Ù‡"+
            signature
        )

    # ØºÙŠØ§Ø¨ Ù…ØªÙ‚Ø·Ø¹ (Ù„ÙŠØ³ Ù…ØªØªØ§Ø¨Ø¹Ø§Ù‹ Ù…Ø¹ Ø§Ù„ÙŠÙˆÙ… Ø§Ù„Ø³Ø§Ø¨Ù‚)
    if consecutive_days == 1 and total_absences > 1:
        return (
            base_header +
            f"âŒ ØªÙ… ØªØ³Ø¬ÙŠÙ„ ØºÙŠØ§Ø¨ Ø§Ø¨Ù†Ùƒ/Ø§Ø¨Ù†ØªÙƒ Ø§Ù„ÙŠÙˆÙ… ({date_str}) Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¨Ø¹Ø¯ ØºÙŠØ§Ø¨Ù‡ Ø³Ø§Ø¨Ù‚Ø§Ù‹.\n"
            "ğŸ“Œ Ù†Ø±Ø¬Ùˆ Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù†ØªØ¸Ø§Ù… Ø§Ù„Ø­Ø¶ÙˆØ± ÙˆØ¯Ø¹Ù… Ø§Ù„Ø·Ø§Ù„Ø¨ Ù„Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ø§Ù„Ù…Ø¯Ø±Ø³Ø© Ø¨Ø§Ù†ØªØ¸Ø§Ù…." +
            signature
        )

    # Ø­Ø§Ù„Ø§Øª Ø¹Ø§Ù…Ø© Ø£Ø®Ø±Ù‰ (Ø§Ø­ØªÙŠØ§Ø·)
    return (
        base_header +
        f"âŒ Ù„Ù… ÙŠØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø­Ø¶ÙˆØ± Ø§Ø¨Ù†Ùƒ/Ø§Ø¨Ù†ØªÙƒ Ø§Ù„ÙŠÙˆÙ… ({date_str}).\n"
        "ğŸ“Œ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø£ÙŠ Ø§Ø³ØªÙØ³Ø§Ø±." +
        signature
    )

def mark_absentees_view(request):
    """
    ÙŠØ³Ø¬Ù„ ØºÙŠØ§Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„Ø°ÙŠÙ† Ù„Ù… ÙŠØ­Ø¶Ø±ÙˆØ§ Ø§Ù„ÙŠÙˆÙ…ØŒ
    ÙˆÙŠØ±Ø³Ù„ Ø¥Ø´Ø¹Ø§Ø± WhatsApp Ù„Ø£ÙˆÙ„ÙŠØ§Ø¡ Ø£Ù…ÙˆØ±Ù‡Ù… Ù…Ø¹ Ø±Ø³Ø§Ù„Ø© Ù…Ø®ØµØµØ© Ù„ÙƒÙ„ Ø­Ø§Ù„Ø©.
    """
    if request.method != 'POST':
        return redirect('barcode_attendance')

    today = timezone.localdate()
    # Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø´Ù‡Ø± Ù„Ø­Ø³Ø§Ø¨ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØºÙŠØ§Ø¨Ø§Øª
    month_start = today.replace(day=1)

    # Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø·Ù„Ø§Ø¨
    all_students = Students.objects.all()
    # Ø§Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„Ø°ÙŠÙ† Ø­Ø¶Ø±ÙˆØ§ Ø§Ù„ÙŠÙˆÙ…
    attended_ids = Attendance.objects.filter(
        attendance_date=today,
        is_absent=False
    ).values_list('student_id', flat=True)
    # Ø§Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„ØºØ§Ø¦Ø¨ÙˆÙ† Ø§Ù„ÙŠÙˆÙ…
    absentees = all_students.exclude(id__in=attended_ids)

    for student in absentees:
        # Ø¥Ø°Ø§ Ù„Ù… Ù†Ø³Ø¬Ù„ Ù„Ù„Ø·Ø§Ù„Ø¨ Ø´ÙŠØ¦Ø§Ù‹ Ø§Ù„ÙŠÙˆÙ…
        if Attendance.objects.filter(student=student, attendance_date=today).exists():
            continue

        # Ø¶Ø¹ Ø¹Ù„Ø§Ù…Ø© ØºÙŠØ§Ø¨
        Attendance.objects.create(
            student=student,
            attendance_date=today,
            is_absent=True
        )

        # Ø­Ø³Ø§Ø¨ Ø§Ù„Ø£ÙŠØ§Ù… Ø§Ù„Ù…ØªØªØ§Ø¨Ø¹Ø© Ù„Ù„ØºÙŠØ§Ø¨
        consecutive_days = 1
        yesterday = today - timedelta(days=1)
        # ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„ØºÙŠØ§Ø¨ Ø£Ù…Ø³
        if Attendance.objects.filter(student=student, attendance_date=yesterday, is_absent=True).exists():
            consecutive_days += 1
            # ØºÙŠØ§Ø¨ Ø§Ù„ÙŠÙˆÙ… Ù‚Ø¨Ù„ Ø£Ù…Ø³
            day_before = today - timedelta(days=2)
            if Attendance.objects.filter(student=student, attendance_date=day_before, is_absent=True).exists():
                consecutive_days += 1

        # Ø­Ø³Ø§Ø¨ Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„ØºÙŠØ§Ø¨Ø§Øª Ù…Ù†Ø° Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ø´Ù‡Ø±
        total_absences = Attendance.objects.filter(
            student=student,
            attendance_date__gte=month_start,
            is_absent=True
        ).count()

        # Ø¨Ù†Ø§Ø¡ Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø©
        text = get_absence_message(student, today, consecutive_days, total_absences)

        # Ø£Ø±Ø³Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø© ÙÙŠ Thread Ù…Ù†ÙØµÙ„
        logger.info(f"Attempting to queue WhatsApp message to {student.father_phone} for student {student.name} (type: absentee_notification)")
        try:
            thread = threading.Thread(
                target=queue_whatsapp_message,
                args=(student.father_phone, text),
                daemon=True
            )
            thread.start()
        except Exception as e:
            logger.error(f"Failed to start WhatsApp thread for student {student.name} (phone: {student.father_phone}, type: absentee_notification): {e}")

    messages.success(request, "âœ… ØªÙ… ØªØ³Ø¬ÙŠÙ„ ØºÙŠØ§Ø¨ Ø§Ù„ÙŠÙˆÙ… ÙˆØ¥Ø±Ø³Ø§Ù„ Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ù…Ø®ØµØµØ© Ù„Ø£ÙˆÙ„ÙŠØ§Ø¡ Ø§Ù„Ø£Ù…ÙˆØ±.")
    return redirect('barcode_attendance')

# def mark_absentees_view(request):
#     """
#     ÙŠØ³Ø¬Ù„ ØºÙŠØ§Ø¨ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„Ø°ÙŠÙ† Ù„Ù… ÙŠØ­Ø¶Ø±ÙˆØ§ Ø§Ù„ÙŠÙˆÙ…ØŒ ÙˆÙŠØ±Ø³Ù„ Ø¥Ø´Ø¹Ø§Ø± WhatsApp Ù„Ø£ÙˆÙ„ÙŠØ§Ø¡ Ø£Ù…ÙˆØ±Ù‡Ù….
#     """
#     if request.method == 'POST':
#         today = timezone.localdate()
#         month_start = date(today.year, today.month, 1)

#         # 1) ÙƒÙ„ Ø§Ù„Ø·Ù„Ø§Ø¨
#         all_students = Students.objects.all()
#         # 2) Ø§Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„Ø°ÙŠÙ† Ø³Ø¬Ù„ÙˆØ§ Ø­Ø¶ÙˆØ±Ù‹Ø§ (Ø­Ù‚ÙŠÙ‚ÙŠÙ‹Ø§) Ø§Ù„ÙŠÙˆÙ…
#         attended_ids = Attendance.objects.filter(
#             attendance_date=today,
#             is_absent=False
#         ).values_list('student_id', flat=True)

#         # 3) Ø§Ù„Ø·Ù„Ø§Ø¨ Ø§Ù„ØºØ§Ø¦Ø¨ÙˆÙ†
#         absentees = all_students.exclude(id__in=attended_ids)

#         for student in absentees:
#             # 4) ØªØ£ÙƒØ¯ Ø£Ù†Ù‘Ù†Ø§ Ù„Ù… Ù†Ø³Ø¬Ù„ Ø­Ø¶ÙˆØ± Ø£Ùˆ ØºÙŠØ§Ø¨ Ù„Ù‡Ù… Ø§Ù„ÙŠÙˆÙ… Ø³Ø§Ø¨Ù‚Ù‹Ø§
#             if not Attendance.objects.filter(student=student, attendance_date=today).exists():
#                 # 5) Ø³Ø¬Ù‘Ù„Ù‡Ù… ÙƒÙ€ØºØ§Ø¦Ø¨
#                 Attendance.objects.create(
#                     student=student,
#                     attendance_date=today,
#                     is_absent=True
#                 )
#                 # 6) Ø£Ø±Ø³Ù„ Ø±Ø³Ø§Ù„Ø© ØºÙŠØ§Ø¨
#                 text = (
#                     f"ğŸ“¢ *ØªÙ†Ø¨ÙŠÙ‡ ÙˆÙ„ÙŠ Ø£Ù…Ø± Ø§Ù„Ø·Ø§Ù„Ø¨ {student.name}*\n\n"
#                     f"âŒ Ù„Ù… ÙŠØªÙ… ØªØ³Ø¬ÙŠÙ„ Ø­Ø¶ÙˆØ± Ø§Ø¨Ù†Ùƒ/Ø§Ø¨Ù†ØªÙƒ Ø§Ù„ÙŠÙˆÙ… `{today:%Y-%m-%d}`.\n"
#                     f"ğŸ“Œ Ø§Ù„Ø±Ø¬Ø§Ø¡ Ù…ØªØ§Ø¨Ø¹Ø© Ø§Ù„Ø£Ù…Ø± Ø£Ùˆ Ø§Ù„ØªÙˆØ§ØµÙ„ Ù…Ø¹Ù†Ø§ ÙÙŠ Ø­Ø§Ù„ ÙˆØ¬ÙˆØ¯ Ù…Ø¨Ø±Ø±.\n\n"
#                     f"Ù…Ø¹ ØªØ­ÙŠØ§ØªØŒ\n*Ù…. Ø¹Ø¨Ø¯Ø§Ù„Ù„Ù‡ Ø¹Ù…Ø±*"
#                 )
#                 threading.Thread(
#                     target=queue_whatsapp_message,
#                     args=(student.father_phone, text),
#                     daemon=True
#                 ).start()

#         messages.success(request, "âœ… ÙŠØªÙ… Ø§Ù„Ø§Ù† ØªØ³Ø¬ÙŠÙ„ ØºÙŠØ§Ø¨ ØºÙŠØ± Ø§Ù„Ø­Ø§Ø¶Ø±ÙŠÙ† Ø§Ù„ÙŠÙˆÙ… ÙˆØ¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª.")
#         return redirect('barcode_attendance')

#     # Ø¥Ø°Ø§ GETØŒ Ø¨Ø¨Ø³Ø§Ø·Ø© Ø£Ø¹Ø¯ ØªÙˆØ¬ÙŠÙ‡ Ù„ØµÙØ­Ø© Ø§Ù„Ø­Ø¶ÙˆØ±
#     return redirect('barcode_attendance')


def income_report_view(request):
    """
    ÙŠØ¹Ø±Ø¶ ØªÙ‚Ø±ÙŠØ± Ø§Ù„Ø¯Ø®Ù„ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø¯ÙÙˆØ¹Ø§Øª Ø§Ù„Ù…Ø³Ø¬Ù„Ø©.
    """
    payments = Payment.objects.all().order_by('-paid_on')
    
    try:
        basics = Basics.objects.get(id=1)
        month_price = basics.month_price
    except Basics.DoesNotExist:
        # Fallback or error handling if Basics instance is not found
        messages.error(request, "Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø³Ø¹Ø± Ø§Ù„Ø´Ù‡Ø± Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ. ÙŠØ±Ø¬Ù‰ Ù…Ø±Ø§Ø¬Ø¹Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª.")
        month_price = 0 # Default to 0 if not set, to avoid further errors
        # Or redirect to an admin/setup page
        # return redirect('some_admin_setup_page')

    total_income = payments.count() * month_price
    
    now = timezone.now()
    month_year = now.strftime("%B %Y") # Example: "October 2023"
    # For Arabic month names, you might need a custom mapping or locale settings
    # For simplicity, using English month names as strftime default
    
    context = {
        'payments': payments,
        'month_price': month_price, # This is the price for EACH payment listed
        'total_income': total_income,
        'month_year': month_year,
    }
    
    return render(request, 'income.html', context)


def home_view(request):
    """
    Renders the home page.
    """
    return render(request, 'home.html')
